import json
from pathlib import Path
import shlex
import functools
from typing import (
    List,
    Callable,
    Iterable,
    Optional,
)
from dataclasses import dataclass, replace
import sys
from .json import (
    Json,
    require_str,
    require_path,
)

@dataclass(frozen=True, order=True)
class Entry:
    directory: Path
    command: str
    file: Path

    @staticmethod
    def from_json(j: Json) -> 'Entry':
        assert isinstance(j, dict)

        return Entry(
            directory=require_path(j['path']),
            command=require_str(j['command']),
            file=require_path(j['path']),
        )

@dataclass(frozen=True)
class Template:
    apply: Callable[[Entry], Entry]

@functools.cache
def load_options_file(p: Path) -> List[str]:
    with p.open("r") as f:
        loaded = shlex.split(f.read())
    return list(loaded)


def get_relpath(entry: Entry, base_dir: Path) -> Path:
    reldir = entry.directory.relative_to(base_dir / "build/normal")
    relative = entry.file.relative_to(base_dir / reldir)
    return relative


def apply_template(template: Entry, entry: Entry, base_dir: Path) -> Entry:
    template_relpath = get_relpath(template, base_dir)
    entry_relpath = get_relpath(entry, base_dir)
    return replace(entry, command=template.command.replace(
        str(template_relpath), str(entry_relpath)
    ),)


def find_template(entries: Iterable[Entry], base_dir: Path) -> Template:
    for entry in entries:
        command = shlex.split(entry.command)
        if (
            Path(command[0]).stem in ["clang++", "g++"]
            and Path(entry.directory).stem == "kernels"
        ):
            def _apply(e: Entry, base_dir: Path=base_dir, template: Entry = entry) -> Entry:
                return apply_template(template, e, base_dir)

            return Template(_apply)
    assert False


def expand_rsp_file(entry: Entry, template: Template) -> bool:
    command = shlex.split(entry.command)
    if Path(command[0]).stem == "nvcc":
        template.apply(entry)
        return True
    return False


def filter_args(entry: Entry) -> Optional[Entry]:
    banned = [
        lambda c: c.startswith("-Xcompiler"),
        lambda c: c.startswith("--generate-code"),
        lambda c: c == "-forward-unknown-to-host-compiler",
    ]

    def is_banned(tok):
        return any(b(tok) for b in banned)

    command = shlex.split(entry.command)

    if Path(command[0]).stem == "nvcc":
        fixed = [tok for tok in command if not is_banned(tok)]
        fixed[2:2] = ["-D__noinline__=noinline"]
        return replace(entry, command=shlex.join(fixed))
    return None


def fix_entry(entry, template):
    did_fix = False
    did_fix |= expand_rsp_file(entry, template)
    did_fix |= filter_args(entry)
    return did_fix


def fix_file(compile_commands: Path, base_dir: Path) -> None:
    assert compile_commands.is_file()
    with compile_commands.open("r") as f:
        entries = json.load(f)

    num_fixed = 0
    template = find_template(entries, base_dir)
    for entry in entries:
        did_fix = fix_entry(entry, template)
        if did_fix:
            num_fixed += 1
    print(f"Fixed {num_fixed} entries.", file=sys.stderr)

    with compile_commands.open("w") as f:
        json.dump(entries, f, indent=2)


@dataclass(frozen=True)
class Args:
    base_dir: Path
    compile_commands: Path


def main(args: Args) -> None:
    fix_file(
        base_dir=args.base_dir,
        compile_commands=args.compile_commands,
    )


if __name__ == "__main__":
    import argparse

    p = argparse.ArgumentParser(
        description="Expand nvcc options files in compile_commands.json generated by cmake",
    )
    p.add_argument("compile_commands", type=Path)
    p.add_argument("base_dir", type=Path)
    args = p.parse_args()

    main(
        args=Args(
            base_dir=args.base_dir,
            compile_commands=args.compile_commands,
        ),
    )
