import json
from pathlib import Path
import shlex
import functools
from typing import List
from dataclasses import dataclass
import sys


@functools.cache
def load_options_file(p: Path) -> List[str]:
    with p.open("r") as f:
        loaded = shlex.split(f.read())
    return list(loaded)


def get_relpath(entry, base_dir: Path):
    file = Path(entry["file"])
    directory = Path(entry["directory"])
    reldir = directory.relative_to(base_dir / "build/normal")
    relative = file.relative_to(base_dir / reldir)
    return relative


def apply_template(template, entry, base_dir: Path):
    template_relpath = get_relpath(template, base_dir)
    entry_relpath = get_relpath(entry, base_dir)
    entry["command"] = template["command"].replace(
        str(template_relpath), str(entry_relpath)
    )


def find_template(entries, base_dir: Path):
    for entry in entries:
        command = shlex.split(entry["command"])
        if (
            Path(command[0]).stem in ["clang++", "g++"]
            and Path(entry["directory"]).stem == "kernels"
        ):
            return lambda e, base_dir=base_dir, template=entry: apply_template(
                template, e, base_dir
            )
    assert False


def expand_rsp_file(entry, template) -> bool:
    command = shlex.split(entry["command"])
    if Path(command[0]).stem == "nvcc":
        template(entry)
        return True
    return False


def filter_args(entry) -> bool:
    banned = [
        lambda c: c.startswith("-Xcompiler"),
        lambda c: c.startswith("--generate-code"),
        lambda c: c == "-forward-unknown-to-host-compiler",
    ]

    def is_banned(tok):
        return any(b(tok) for b in banned)

    command = shlex.split(entry["command"])

    if Path(command[0]).stem == "nvcc":
        fixed = [tok for tok in command if not is_banned(tok)]
        fixed[2:2] = ["-D__noinline__=noinline"]
        entry["command"] = shlex.join(fixed)
    return False


def fix_entry(entry, template):
    did_fix = False
    did_fix |= expand_rsp_file(entry, template)
    did_fix |= filter_args(entry)
    return did_fix


def fix_file(compile_commands: Path, base_dir: Path) -> None:
    assert compile_commands.is_file()
    with compile_commands.open("r") as f:
        entries = json.load(f)

    num_fixed = 0
    template = find_template(entries, base_dir)
    for entry in entries:
        did_fix = fix_entry(entry, template)
        if did_fix:
            num_fixed += 1
    print(f"Fixed {num_fixed} entries.", file=sys.stderr)

    with compile_commands.open("w") as f:
        json.dump(entries, f, indent=2)


@dataclass(frozen=True)
class Args:
    base_dir: Path
    compile_commands: Path


def main(args: Args) -> None:
    fix_file(
        base_dir=args.base_dir,
        compile_commands=args.compile_commands,
    )


if __name__ == "__main__":
    import argparse

    p = argparse.ArgumentParser(
        description="Expand nvcc options files in compile_commands.json generated by cmake",
    )
    p.add_argument("compile_commands", type=Path)
    p.add_argument("base_dir", type=Path)
    args = p.parse_args()

    main(
        args=Args(
            base_dir=args.base_dir,
            compile_commands=args.compile_commands,
        ),
    )
